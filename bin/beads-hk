#!/usr/bin/env bash
# beads-hk: Git hook integration for Beads issue tracker
# https://github.com/steveyegge/beads + https://hk.jdx.dev
#
# MIT License

set -euo pipefail

VERSION="0.1.0"

BEADS_CMD="${BEADS_CMD:-bd}"
BEADS_HK_STRICT="${BEADS_HK_STRICT:-false}"
BEADS_HK_AUTO_FILE="${BEADS_HK_AUTO_FILE:-false}"
BEADS_HK_MAX_FILE_LINES="${BEADS_HK_MAX_FILE_LINES:-500}"
BEADS_HK_MAX_FUNC_LINES="${BEADS_HK_MAX_FUNC_LINES:-50}"

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m' # No Color

#------------------------------------------------------------------------------
# Utilities
#------------------------------------------------------------------------------

usage() {
	cat <<EOF
${BOLD}beads-hk${NC} v${VERSION} - Git hook integration for Beads issue tracker

${BOLD}USAGE:${NC}
    beads-hk <command> [args]

${BOLD}COMMANDS:${NC}
    check-todos <files...>          Check for TODOs without bead references
    health-check <files...>         Run code health checks, optionally file beads
    prepare-commit-msg <msg-file>   Suggest bead references for commit
    validate-commit-msg <msg-file>  Validate commit references valid beads
    post-commit                     Update beads based on commit message
    check-merge-risk                Warn about potential merge conflicts
    version                         Show version

${BOLD}ENVIRONMENT:${NC}
    BEADS_CMD                Beads CLI command (default: bd)
    BEADS_HK_STRICT          Fail on issues instead of warn (default: false)
    BEADS_HK_AUTO_FILE       Auto-file beads for issues found (default: false)
    BEADS_HK_MAX_FILE_LINES  Large file threshold (default: 500)
    BEADS_HK_MAX_FUNC_LINES  Long function threshold (default: 50)

${BOLD}EXAMPLES:${NC}
    # Check staged files for naked TODOs
    beads-hk check-todos src/*.py

    # Run health checks with auto-filing
    BEADS_HK_AUTO_FILE=true beads-hk health-check src/*.py

    # Strict mode (fail instead of warn)
    BEADS_HK_STRICT=true beads-hk check-todos src/*.py

EOF
	exit 0
}

version() {
	echo "beads-hk v${VERSION}"
	exit 0
}

log_info() {
	echo -e "${BLUE}ℹ${NC} $*"
}

log_success() {
	echo -e "${GREEN}✓${NC} $*"
}

log_warn() {
	echo -e "${YELLOW}⚠${NC} $*"
}

log_error() {
	echo -e "${RED}✗${NC} $*"
}

# Check if beads is available
check_beads() {
	if ! command -v "$BEADS_CMD" &>/dev/null; then
		log_warn "Beads not found ($BEADS_CMD). Skipping beads integration."
		exit 0
	fi
}

# Extract bead IDs from text (BD-xxx format)
extract_bead_ids() {
	local input="$1"
	if [[ -f "$input" ]]; then
		grep -oE 'BD-[a-zA-Z0-9]+' "$input" 2>/dev/null || true
	else
		echo "$input" | grep -oE 'BD-[a-zA-Z0-9]+' 2>/dev/null || true
	fi
}

# Check if a bead exists
bead_exists() {
	local bead_id="$1"
	$BEADS_CMD show "$bead_id" &>/dev/null
}

# Should we fail or just warn?
maybe_fail() {
	if [[ "$BEADS_HK_STRICT" == "true" ]]; then
		exit 1
	fi
}

#------------------------------------------------------------------------------
# check-todos: Scan files for TODOs without bead references
#------------------------------------------------------------------------------
cmd_check_todos() {
	local files=("$@")
	local issues_found=0
	local naked_todos=()

	if [[ ${#files[@]} -eq 0 ]]; then
		log_warn "No files provided to check-todos"
		return 0
	fi

	for file in "${files[@]}"; do
		[[ -f "$file" ]] || continue

		# Find TODO/FIXME/HACK comments
		while IFS=: read -r line_num content; do
			# Check if line has a bead reference
			if ! echo "$content" | grep -qE 'BD-[a-zA-Z0-9]+'; then
				naked_todos+=("$file:$line_num:$content")
				((++issues_found))
			fi
		done < <(grep -n -E '(TODO|FIXME|HACK)(\([^)]*\))?:?' "$file" 2>/dev/null || true)
	done

	if [[ $issues_found -gt 0 ]]; then
		log_warn "Found $issues_found TODO(s) without bead references:"
		echo ""
		for todo in "${naked_todos[@]}"; do
			IFS=':' read -r file line content <<<"$todo"
			echo -e "  ${BOLD}$file:$line${NC}"
			echo "    $content"
		done
		echo ""
		echo "To fix, either:"
		echo "  1. Add bead reference: ${BOLD}TODO(BD-xxx): description${NC}"
		echo "  2. File a new bead:    ${BOLD}$BEADS_CMD add --title 'TODO: description'${NC}"
		echo ""

		maybe_fail
	else
		log_success "All TODOs have bead references"
	fi
}

#------------------------------------------------------------------------------
# health-check: Run code health checks on files
#------------------------------------------------------------------------------
cmd_health_check() {
	local files=("$@")
	local issues_found=0

	if [[ ${#files[@]} -eq 0 ]]; then
		log_warn "No files provided to health-check"
		return 0
	fi

	for file in "${files[@]}"; do
		[[ -f "$file" ]] || continue

		# Check file length
		local line_count
		line_count=$(wc -l <"$file" | tr -d ' ')

		if [[ $line_count -gt $BEADS_HK_MAX_FILE_LINES ]]; then
			((++issues_found))
			log_warn "Large file: ${BOLD}$file${NC} ($line_count lines, max: $BEADS_HK_MAX_FILE_LINES)"

			if [[ "$BEADS_HK_AUTO_FILE" == "true" ]]; then
				local bead_id
				bead_id=$($BEADS_CMD add \
					--title "Health: Split large file $file" \
					--description "File has $line_count lines (threshold: $BEADS_HK_MAX_FILE_LINES). Consider splitting into smaller modules." \
					--tag "health" \
					--tag "auto-filed" \
					2>/dev/null | grep -oE 'BD-[a-zA-Z0-9]+' || echo "")
				if [[ -n "$bead_id" ]]; then
					log_info "  → Filed bead: $bead_id"
				fi
			fi
		fi

		# Check for long functions (language-specific)
		case "$file" in
		*.py)
			check_python_functions "$file"
			;;
		*.ts | *.js | *.tsx | *.jsx)
			check_js_functions "$file"
			;;
		*.go)
			check_go_functions "$file"
			;;
		*.rs)
			check_rust_functions "$file"
			;;
		esac
	done

	if [[ $issues_found -gt 0 ]]; then
		echo ""
		log_warn "Found $issues_found code health issue(s)"
		maybe_fail
	else
		log_success "Code health checks passed"
	fi
}

check_python_functions() {
	local file="$1"
	local in_func=false
	local func_name=""
	local func_start=0
	local line_num=0

	# shellcheck disable=SC2094  # We're only reading $file, not writing
	while IFS= read -r line; do
		((++line_num))

		# Detect function start
		if [[ "$line" =~ ^[[:space:]]*def[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*) ]]; then
			# If we were in a function, check its length
			if [[ "$in_func" == true ]]; then
				check_function_length "$file" "$func_name" "$func_start" "$((line_num - 1))"
			fi
			func_name="${BASH_REMATCH[1]}"
			func_start=$line_num
			in_func=true
		fi
	done <"$file"

	# Check last function
	if [[ "$in_func" == true ]]; then
		check_function_length "$file" "$func_name" "$func_start" "$line_num"
	fi
}

check_js_functions() {
	local file="$1"
	# Simplified: just look for function declarations and count braces
	# This is a heuristic and won't catch all cases
	awk -v max="$BEADS_HK_MAX_FUNC_LINES" -v file="$file" '
        /function[[:space:]]+[a-zA-Z_]/ { 
            if (start > 0 && NR - start > max) {
                print "LONG:" file ":" name ":" NR-start
            }
            start = NR
            match($0, /function[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*)/, arr)
            name = arr[1]
        }
        /^[[:space:]]*}[[:space:]]*(\/\/.*)?$/ && start > 0 {
            if (NR - start > max) {
                print "LONG:" file ":" name ":" NR-start
            }
            start = 0
        }
    ' "$file" 2>/dev/null | while IFS=: read -r _ f n len; do
		report_long_function "$f" "$n" "$len"
	done
}

check_go_functions() {
	local file="$1"
	awk -v max="$BEADS_HK_MAX_FUNC_LINES" -v file="$file" '
        /^func[[:space:]]/ { 
            if (start > 0 && NR - start > max) {
                print "LONG:" file ":" name ":" NR-start
            }
            start = NR
            match($0, /func[[:space:]]+(\([^)]*\)[[:space:]]+)?([a-zA-Z_][a-zA-Z0-9_]*)/, arr)
            name = arr[2]
        }
        /^}$/ && start > 0 {
            if (NR - start > max) {
                print "LONG:" file ":" name ":" NR-start
            }
            start = 0
        }
    ' "$file" 2>/dev/null | while IFS=: read -r _ f n len; do
		report_long_function "$f" "$n" "$len"
	done
}

check_rust_functions() {
	local file="$1"
	awk -v max="$BEADS_HK_MAX_FUNC_LINES" -v file="$file" '
        /^[[:space:]]*pub[[:space:]]+fn|^[[:space:]]*fn[[:space:]]/ { 
            if (start > 0 && NR - start > max) {
                print "LONG:" file ":" name ":" NR-start
            }
            start = NR
            match($0, /fn[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*)/, arr)
            name = arr[1]
        }
        /^}$/ && start > 0 {
            if (NR - start > max) {
                print "LONG:" file ":" name ":" NR-start
            }
            start = 0
        }
    ' "$file" 2>/dev/null | while IFS=: read -r _ f n len; do
		report_long_function "$f" "$n" "$len"
	done
}

check_function_length() {
	local file="$1"
	local name="$2"
	local start="$3"
	local end="$4"
	local length=$((end - start))

	if [[ $length -gt $BEADS_HK_MAX_FUNC_LINES ]]; then
		report_long_function "$file" "$name" "$length"
	fi
}

report_long_function() {
	local file="$1"
	local name="$2"
	local length="$3"

	((issues_found++)) 2>/dev/null || issues_found=1
	log_warn "Long function: ${BOLD}$name${NC} in $file ($length lines, max: $BEADS_HK_MAX_FUNC_LINES)"

	if [[ "$BEADS_HK_AUTO_FILE" == "true" ]]; then
		local bead_id
		bead_id=$($BEADS_CMD add \
			--title "Health: Refactor long function $name" \
			--description "Function $name in $file has $length lines (threshold: $BEADS_HK_MAX_FUNC_LINES). Consider extracting helper functions." \
			--tag "health" \
			--tag "auto-filed" \
			2>/dev/null | grep -oE 'BD-[a-zA-Z0-9]+' || echo "")
		if [[ -n "$bead_id" ]]; then
			log_info "  → Filed bead: $bead_id"
		fi
	fi
}

#------------------------------------------------------------------------------
# prepare-commit-msg: Add bead suggestions to commit message
#------------------------------------------------------------------------------
cmd_prepare_commit_msg() {
	local msg_file="${1:-}"

	if [[ -z "$msg_file" || ! -f "$msg_file" ]]; then
		log_error "Commit message file required"
		exit 1
	fi

	# Get in-progress beads
	local in_progress
	in_progress=$($BEADS_CMD list --status=in-progress 2>/dev/null || true)

	if [[ -n "$in_progress" ]]; then
		# Check if message already has bead references
		if grep -qE 'BD-[a-zA-Z0-9]+' "$msg_file" 2>/dev/null; then
			return 0
		fi

		# Append suggestions as comments
		{
			echo ""
			echo "# ─────────────────────────────────────────────────────────────"
			echo "# Beads in progress (add reference with 'Relates-to: BD-xxx'):"
			echo "#"
			echo "$in_progress" | while read -r line; do
				echo "#   $line"
			done
			echo "#"
			echo "# To close a bead: 'Closes BD-xxx' or 'Fixes BD-xxx'"
			echo "# ─────────────────────────────────────────────────────────────"
		} >>"$msg_file"
	fi
}

#------------------------------------------------------------------------------
# validate-commit-msg: Ensure commit references valid beads
#------------------------------------------------------------------------------
cmd_validate_commit_msg() {
	local msg_file="${1:-}"

	if [[ -z "$msg_file" || ! -f "$msg_file" ]]; then
		log_error "Commit message file required"
		exit 1
	fi

	# Extract bead references
	local bead_ids
	bead_ids=$(extract_bead_ids "$msg_file")

	if [[ -z "$bead_ids" ]]; then
		if [[ "$BEADS_HK_STRICT" == "true" ]]; then
			log_error "Commit message must reference a bead (BD-xxx)"
			echo ""
			echo "Add one of:"
			echo "  Relates-to: BD-xxx"
			echo "  Closes BD-xxx"
			echo "  Fixes BD-xxx"
			exit 1
		fi
		return 0
	fi

	# Validate each referenced bead exists
	local invalid=()
	local valid=()
	for bead_id in $bead_ids; do
		if bead_exists "$bead_id"; then
			valid+=("$bead_id")
		else
			invalid+=("$bead_id")
		fi
	done

	if [[ ${#invalid[@]} -gt 0 ]]; then
		log_error "Invalid bead references: ${invalid[*]}"
		exit 1
	fi

	log_success "Bead references validated: ${valid[*]}"
}

#------------------------------------------------------------------------------
# post-commit: Update beads based on commit
#------------------------------------------------------------------------------
cmd_post_commit() {
	local commit_msg
	commit_msg=$(git log -1 --pretty=%B 2>/dev/null || true)

	if [[ -z "$commit_msg" ]]; then
		return 0
	fi

	# Look for "Closes BD-xxx" or "Fixes BD-xxx" patterns
	local close_pattern='(Closes|Fixes|Resolves)[[:space:]]+BD-[a-zA-Z0-9]+'
	local close_ids
	close_ids=$(echo "$commit_msg" | grep -oE "$close_pattern" | grep -oE 'BD-[a-zA-Z0-9]+' || true)

	local commit_hash
	commit_hash=$(git rev-parse --short HEAD 2>/dev/null || true)

	if [[ -z "$close_ids" ]]; then
		return 0
	fi

	for bead_id in $close_ids; do
		if bead_exists "$bead_id"; then
			log_info "Closing $bead_id (commit: $commit_hash)"
			$BEADS_CMD update "$bead_id" --status=done 2>/dev/null || true
		else
			log_warn "Bead $bead_id not found, skipping"
		fi
	done
}

#------------------------------------------------------------------------------
# check-merge-risk: Warn about potential merge wall situations
#------------------------------------------------------------------------------
cmd_check_merge_risk() {
	# Get files changed in current branch vs main/master
	local changed_files
	changed_files=$(git diff --name-only origin/main...HEAD 2>/dev/null ||
		git diff --name-only origin/master...HEAD 2>/dev/null ||
		git diff --name-only HEAD~10...HEAD 2>/dev/null || true)

	if [[ -z "$changed_files" ]]; then
		log_success "No changed files to analyze"
		return 0
	fi

	# Get in-progress beads
	local in_progress
	in_progress=$($BEADS_CMD list --status=in-progress 2>/dev/null || true)

	if [[ -z "$in_progress" ]]; then
		log_success "No merge risk detected (no other in-progress beads)"
		return 0
	fi

	local count
	count=$(echo "$in_progress" | wc -l | tr -d ' ')

	log_warn "There are $count other in-progress bead(s) that may conflict:"
	echo ""
	echo "$in_progress" | while read -r line; do
		echo "  • $line"
	done
	echo ""
	echo "Consider coordinating before pushing large changes."
	echo "Run '${BOLD}$BEADS_CMD list --status=in-progress${NC}' for details."
}

#------------------------------------------------------------------------------
# Main dispatch
#------------------------------------------------------------------------------
main() {
	if [[ $# -lt 1 ]]; then
		usage
	fi

	local cmd="$1"
	shift

	case "$cmd" in
	check-todos)
		check_beads
		cmd_check_todos "$@"
		;;
	health-check)
		check_beads
		cmd_health_check "$@"
		;;
	prepare-commit-msg)
		check_beads
		cmd_prepare_commit_msg "$@"
		;;
	validate-commit-msg)
		check_beads
		cmd_validate_commit_msg "$@"
		;;
	post-commit)
		check_beads
		cmd_post_commit "$@"
		;;
	check-merge-risk)
		check_beads
		cmd_check_merge_risk "$@"
		;;
	version | --version | -v)
		version
		;;
	-h | --help | help)
		usage
		;;
	*)
		log_error "Unknown command: $cmd"
		echo ""
		usage
		;;
	esac
}

main "$@"
